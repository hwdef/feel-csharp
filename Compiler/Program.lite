"Compiler" {
    "Antlr4/Runtime"
    "System"
    "System/IO"
    "System/Text"
}

_ReadPath: Str
_PathLine: Str

Main(args: [:]Str->) {
    # 检查系统平台，区分路径字符 #
    os := Environment.OSVersion.Platform
    ? os == PlatformID.Unix | os == PlatformID.MacOSX {
        _ReadPath = "./"
        _PathLine = "/"
    } _ {
        _ReadPath = ".\\"
        _PathLine = "\\"
    }

    Compiled(_ReadPath)

    Prt("Completed")
    Rd()
}

Compiled(path: Str->) {
    # 获取相对路径下所有文件 #
    Files := Directory.GetFiles(path, "*.lite")
    Files @ file {
        # 文件流读文件 #
        <FileStream>(file, FileMode.Open) ! fsRead
        ! {
            FSLength := fsRead.Length:(Int)
            ByteBlock := Array<U8>(FSLength)
            r := fsRead.Read(ByteBlock, 0, ByteBlock.Length)
            Input := Encoding.UTF8.GetString(ByteBlock)
            # 移除平台差异 #
            Input.Replace("\r", "")

            Stream := <AntlrInputStream>(Input)
            Lexer := <LiteLexer>(Stream)
            Tokens := <CommonTokenStream>(Lexer)
            Parser := <LiteParser>(Tokens)
            Parser.BuildParseTree = True
            Parser.RemoveErrorListeners()
            Parser.AddErrorListener(ErrorListener{ FileDir = file })

            AST := Parser.program()

            Visitor := LiteLangVisitor{}
            Result := Visitor.Visit(AST)

            # 文件流写文件,使用覆盖模式 #
            ByteResult := Encoding.UTF8.GetBytes(Result.to_Str())  # 转换为字节 #
            <FileStream>(_ReadPath + file.sub_Str(0, file.Length - 5) + ".cs", FileMode.Create) ! fsWrite
            fsWrite.Write(ByteResult, 0, ByteResult.Length)
        } err: Exception {
            Prt(err)
            <-
        }
    }

    Folders := Directory.GetDirectories(path)
    Folders @ folder {
        Compiled(folder)
    }
}
